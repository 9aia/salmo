#!/usr/bin/env bash
# This script was generated by bashly 1.3.2 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
salmo_usage() {
  printf "salmo - Simple framework to manage your personal desktop environment. Easily apply configuration files, install packages, and streamline your setup with flexible commands.\n\n"

  printf "%s\n" "Usage:"
  printf "  salmo COMMAND\n"
  printf "  salmo [COMMAND] --help | -h\n"
  printf "  salmo --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Apply files and install packages\n" "prepare"
  printf "  %s   Same as prepare but with hot-reload\n" "dev    "
  printf "  %s   Generate a custom production-ready CLI that includes usb-setup and post-boot-install commands\n" "build  "
  printf "  %s   Install packages listed in pkglist.txt file\n" "install"
  printf "  %s   Pull packages and files\n" "pull   "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
salmo_prepare_usage() {
  printf "salmo prepare - Apply files and install packages\n\n"

  printf "%s\n" "Usage:"
  printf "  salmo prepare [OPTIONS]\n"
  printf "  salmo prepare --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--dry-run, -n"
    printf "    Show what would be done without making changes\n"
    echo

    # :flag.usage
    printf "  %s\n" "--config, -c PATH"
    printf "    Path to the configuration file\n"
    printf "    %s\n" "Default: salmo.config.yml"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  salmo prepare\n"
    printf "  salmo prepare --dry-run\n"
    echo

  fi
}

# :command.usage
salmo_dev_usage() {
  printf "salmo dev - Same as prepare but with hot-reload\n\n"
  printf "Alias: start\n"
  echo

  printf "%s\n" "Usage:"
  printf "  salmo dev [OPTIONS]\n"
  printf "  salmo dev --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--config, -c PATH"
    printf "    Path to the configuration file\n"
    printf "    %s\n" "Default: salmo.config.yml"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  salmo dev\n"
    echo

  fi
}

# :command.usage
salmo_build_usage() {
  printf "salmo build - Generate a custom production-ready CLI that includes usb-setup and post-boot-install commands\n\n"

  printf "%s\n" "Usage:"
  printf "  salmo build [OPTIONS]\n"
  printf "  salmo build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--config, -c PATH"
    printf "    Path to the configuration file\n"
    printf "    %s\n" "Default: salmo.config.yml"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  salmo build\n"
    echo

  fi
}

# :command.usage
salmo_install_usage() {
  printf "salmo install - Install packages listed in pkglist.txt file\n\n"

  printf "%s\n" "Usage:"
  printf "  salmo install [OPTIONS]\n"
  printf "  salmo install --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--dry-run, -n"
    printf "    Show what would be installed without making changes\n"
    echo

    # :flag.usage
    printf "  %s\n" "--file, -f FILEPATH"
    printf "    Path to the pkglist.txt file\n"
    printf "    %s\n" "Default: pkglist.txt"
    echo

    # :flag.usage
    printf "  %s\n" "--config, -c CONFIGPATH"
    printf "    Path to the configuration file\n"
    printf "    %s\n" "Default: salmo.config.yml"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  salmo install\n"
    printf "  salmo install --dry-run\n"
    printf "  salmo install --file custom_packages.txt\n"
    echo

  fi
}

# :command.usage
salmo_pull_usage() {
  printf "salmo pull - Pull packages and files\n\n"

  printf "%s\n" "Usage:"
  printf "  salmo pull\n"
  printf "  salmo pull --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  salmo pull\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
enable_auto_colors() {
  if [[ -z ${NO_COLOR+x} && ! -t 1 ]]; then
    NO_COLOR=1
  fi
}

print_in_color() {
  local color="$1"
  shift
  if [[ "${NO_COLOR:-}" == "" ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
black() { print_in_color "\e[30m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }

bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }

red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
black_bold() { print_in_color "\e[1;30m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }

red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }
black_underlined() { print_in_color "\e[4;30m" "$*"; }
white_underlined() { print_in_color "\e[4;37m" "$*"; }

# src/lib/logger.sh

enable_auto_colors() {
  if [[ -z ${NO_COLOR+x} && ! -t 1 ]]; then
    NO_COLOR=1
  fi
}

print_in_color() {
  local color="$1"
  shift
  if [[ "${NO_COLOR:-}" == "" ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    print_in_color "${BLUE}" "[INFO] $1"
}

log_success() {
    print_in_color "${GREEN}" "[SUCCESS] $1"
}

log_warning() {
    print_in_color "${YELLOW}" "[WARNING] $1"
}

log_error() {
    print_in_color "${RED}" "[ERROR] $1"
}

log_debug() {
    print_in_color "${BLUE}" "[DEBUG] $1"
}

# src/lib/yaml.sh
yaml_load() {
  local prefix=$2
  local s='[[:space:]]*' w='[a-zA-Z0-9_]*'
  local fs

  fs=$(echo @ | tr @ '\034')

  sed -ne "s|^\($s\):|\1|" \
    -e "s|^\($s\)\($w\)$s:${s}[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
    -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p" "$1" |
    awk -F"$fs" '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'"$prefix"'",vn, $2, $3);
      }
    }'
}

# :command.command_functions
# :command.function
salmo_prepare_command() {

  # src/prepare_command.sh
  prepare_home_files() {
      log_info "Preparing home files..."

      if [[ ! -d "$SALMO_FILES_DIR$HOME" ]]; then
          log_warning "No home files directory found at $SALMO_FILES_DIR$HOME. Skipping home files preparation."
          return
      fi

      # Recursively copies everything from the directory path formed by concatenating the value of $SALMO_FILES_DIR and $HOME into your home directory ($HOME). All files and subdirectories from the source are duplicated into the destination, preserving the directory structure. If files with the same name exist in the destination, they will be overwritten.
      log_info "Copying all home files from $SALMO_FILES_DIR$HOME to $HOME"
      rsync -av "$SALMO_FILES_DIR$HOME"/. "$HOME"/

      log_success "Home files copied successfully!"
  }

  prepare_non_home_files() {
      log_info "Copying all non-home files..."

      # Copy all files except $HOME from $SALMO_FILES_DIR to /
      sudo rsync -av --exclude="$HOME" "$SALMO_FILES_DIR"/ /

      log_success "Non-home files copied successfully!"
  }

  apply_bin() {
      log_info "Applying binary executables..."

      log_info "Updating permissions for binary executables..."
      sudo chmod +x /usr/local/bin/*

      log_info "Reloading .bashrc to apply changes..."
      source ~/.bashrc

      log_success "Binary executables applied successfully!"
  }

  apply_aliases() {
      log_info "Applying aliases..."

      log_info "Updating permissions for aliases..."
      sudo chmod +x "/usr/local/aliases"/*

      log_info "Ensuring aliases are sourced in ~/.bashrc"
      for alias_file in "/usr/local/aliases"/*.sh; do
          if [[ -f "$alias_file" ]]; then
              alias_source_line="source $alias_file"

              if ! grep -qxF "$alias_source_line" ~/.bashrc; then
                  echo "$alias_source_line" >> ~/.bashrc
              fi
          fi
      done

      log_info "Reloading .bashrc to apply changes..."
      source ~/.bashrc

      log_success "Aliases applied successfully!"
  }

  apply_special_files() {
      log_info "Applying special files..."

      apply_aliases
      apply_bin

      log_success "Special files applied successfully!"
  }

  prepare() {
      prepare_home_files
      prepare_non_home_files
      apply_special_files
  }

  prepare

}

# :command.function
salmo_dev_command() {

  # src/dev_command.sh
  handle_config_file_change() {
      local file="$1" # e.g. /home/luis/GitHub/luisfuturist/de/src/config/hypr/hyprland.conf
      local event="$2"

      # Skip if it's a directory or temp file
      if [[ -d "$file" ]] || [[ "$file" == *"~" ]] || [[ "$file" == *".tmp" ]]; then
          return
      fi

      local rel_path="${file#$SALMO_FILES_DIR}" # e.g. /hypr/hyprland.conf
      local target_path="$DEST_CONFIG_DIR$rel_path" # e.g. ~/.config/hypr/hyprland.conf

      if [[ "$event" == "DELETE" ]]; then
          if [[ -f "$target_path" ]]; then
              remove_config "$rel_path" "$target_path"
              log_info "Removed: $target_path"
          fi
      elif [[ "$event" == "MOVED_FROM" ]]; then
          if [[ -f "$target_path" ]]; then
              remove_config "$rel_path" "$target_path"
              log_info "Removed (cause: moved): $target_path"
          fi
      elif [[ "$event" == "CREATE" ]]; then
          update_config "$rel_path" "$target_path"
          log_info "Created: $target_path"
          handle_special_config_file_change "$rel_path"
      elif [[ "$event" == "MODIFY" ]] || [[ "$event" == "MOVED_TO" ]]; then
          update_config "$rel_path" "$target_path"
          log_info "Modified: $target_path"
          handle_special_config_file_change "$rel_path"
      fi
  }

  update_config() {
      local rel_path="$1"
      local target_path="$2"
      # Create target directory if it doesn't exist
      mkdir -p "$(dirname "$target_path")"
      cp "$file" "$target_path"

      log_debug "Updated $target_path"
  }

  remove_config() {
      local rel_path="$1"
      local target_path="$2"

      # Remove the file
      rm "$target_path"

      # Remove empty parent directories up to ~/.config
      local parent_dir="$(dirname "$target_path")"
      while [[ "$parent_dir" != "$DEST_CONFIG_DIR" ]] && [[ -d "$parent_dir" ]] && [[ -z "$(ls -A "$parent_dir")" ]]; do
          rmdir "$parent_dir"
          log_debug "Removed empty directory: $parent_dir"
          parent_dir="$(dirname "$parent_dir")"
      done
  }

  handle_special_config_file_change() {
      local rel_path="$1"

      case "$rel_path" in
          /hypr/hyprland.conf)
              echo "Reloading Hyprland configuration..."
              hyprctl reload 2>/dev/null || echo "Note: Could not reload Hyprland (not running?)"
              ;;
          /waybar/*)
              echo "Restarting Waybar... (no-op)"
              # TODO: Implement waybar restart logic
              ;;
      esac
  }

  handle_bin_file_change() {
      local file="$1" # e.g. /home/luis/GitHub/luisfuturist/de/src/bin/yazi-x
      local event="$2"

      local rel_path="${file#$SRC_BIN_DIR}" # e.g. /yazi-x
      local target_path="$DEST_BIN_DIR$rel_path" # e.g. ~/.config/bin/yazi-x

      if [[ "$event" == "DELETE" ]] || [[ "$event" == "MOVED_FROM" ]]; then
          if [[ -f "$target_path" ]]; then
              sudo rm "$target_path"
              log_info "Removed: $target_path"
          fi
      elif [[ "$event" == "CREATE" ]] || [[ "$event" == "MOVED_TO" ]]; then
          # Create target directory if it doesn't exist
          mkdir -p "$(dirname "$target_path")"
          sudo cp "$file" "$target_path"
          # Make the script executable
          sudo chmod +x "$target_path"
          log_info "Created: $target_path"
      elif [[ "$event" == "MODIFY" ]]; then
          # Create target directory if it doesn't exist
          mkdir -p "$(dirname "$target_path")"
          sudo cp "$file" "$target_path"
          # Make the script executable
          sudo chmod +x "$target_path"
          log_info "Modified: $target_path"
      fi
  }

  handle_home_file_change() {
      # TODO: implement this
      log_info "Not implemented yet"
  }

  handle_non_home_file_change() {
      # TODO: implement this
      log_info "Not implemented yet"
  }

  route_file_change() {
      local file="$1"
      local event="$2"

      log_debug "File changed: $file (event: $event)"

      # Determine file type and route to appropriate handler
      if [[ "$file" == "$SRC_CONFIG_DIR"* ]]; then
          handle_config_file_change "$file" "$event"
      elif [[ "$file" == "$SRC_BIN_DIR"* ]]; then
          handle_bin_file_change "$file" "$event"
      elif [[ "$file" == "$SRC_GITCONFIG_FILE" ]]; then
          handle_gitconfig_file_change "$file" "$event"
      elif [[ "$file" == "$SRC_ALIASES_DIR"* ]]; then
          handle_aliases_file_change "$file" "$event"
      elif [[ "$file" == "$SRC_BACKGROUNDS_DIR"* ]]; then
          handle_backgrounds_file_change "$file" "$event"
      elif [[ "$file" == "$SRC_ICONS_DIR"* ]]; then
          handle_icons_file_change "$file" "$event"
      elif [[ "$file" == "$SRC_THEMES_DIR"* ]]; then
          handle_themes_file_change "$file" "$event"
      else
          log_debug "Unknown file type: $file (event: $event)"
      fi
  }

  check_required_software() {
      log_info "Checking required software..."

      if ! command -v inotifywait &> /dev/null; then
          log_info "inotifywait is not installed. Installing inotify-tools package..."
          sudo pacman -S inotify-tools
          if ! command -v inotifywait &> /dev/null; then
              log_error "Failed to install inotify-tools package."
              exit 1
          fi
          log_success "inotify-tools installed successfully!"
      fi
  }

  watch_files() {
      log_info "Watching for changes in project directories..."
      log_info "Press Ctrl+C to stop watching"

      # Watch for file changes in all project directories
      inotifywait -m -r -e create,modify,delete,moved_from,moved_to --format '%w%f %e' \
          "$SRC_FILES_DIR" |
      while read file event; do
          #route_file_change "$file" "$event"
          echo "File changed: $file (event: $event)"
      done
  }

  check_required_software
  watch_files

}

# :command.function
salmo_build_command() {

  # src/build_command.sh
  echo "# This file is located at 'src/build_command.sh'."
  echo "# It contains the implementation for the 'salmo build' command."
  echo "# The code you write here will be wrapped by a function named 'salmo_build_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

  # TODO: generate dist/luis-de for setup_usb and install

}

# :command.function
salmo_install_command() {

  # src/install_command.sh
  echo "# This file is located at 'src/install_command.sh'."
  echo "# It contains the implementation for the 'salmo install' command."
  echo "# The code you write here will be wrapped by a function named 'salmo_install_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
salmo_pull_command() {

  # src/pull_command.sh
  pull_packages() {
      log_info "Pulling packages..."

      pacman -Qmq > src/packages/yay.txt
      pacman -Qeq > src/packages/pacman.txt

      # Sort the package lists to ensure comm works correctly
      sort -o src/packages/pacman_sorted.txt src/packages/pacman.txt
      sort -o src/packages/yay_sorted.txt src/packages/yay.txt

      # Use comm to find packages in the pacman list that aren't in the yay list
      # The -23 flags suppress lines unique to file2 and lines common to both
      comm -23 src/packages/pacman_sorted.txt src/packages/yay_sorted.txt > src/packages/pacman_filtered.txt

      # Replace the original pacman list with the filtered one
      mv src/packages/pacman_filtered.txt src/packages/pacman.txt

      # Clean up the temporary sorted files
      rm src/packages/pacman_sorted.txt src/packages/yay_sorted.txt

      log_success "Packages pulled successfully"
  }

  pull_packages

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        salmo_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    prepare)
      action="prepare"
      shift
      salmo_prepare_parse_requirements "$@"
      shift $#
      ;;

    dev | start)
      action="dev"
      shift
      salmo_dev_parse_requirements "$@"
      shift $#
      ;;

    build)
      action="build"
      shift
      salmo_build_parse_requirements "$@"
      shift $#
      ;;

    install)
      action="install"
      shift
      salmo_install_parse_requirements "$@"
      shift $#
      ;;

    pull)
      action="pull"
      shift
      salmo_pull_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      salmo_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
salmo_prepare_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        salmo_prepare_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="prepare"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --dry-run | -n)

        # :flag.case_no_arg
        args['--dry-run']=1
        shift
        ;;

      # :flag.case
      --config | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--config']="$2"
          shift
          shift
        else
          printf "%s\n" "--config requires an argument: --config, -c PATH" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--config']:-} ]] || args['--config']="salmo.config.yml"

}

# :command.parse_requirements
salmo_dev_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        salmo_dev_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="dev"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --config | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--config']="$2"
          shift
          shift
        else
          printf "%s\n" "--config requires an argument: --config, -c PATH" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--config']:-} ]] || args['--config']="salmo.config.yml"

}

# :command.parse_requirements
salmo_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        salmo_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --config | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--config']="$2"
          shift
          shift
        else
          printf "%s\n" "--config requires an argument: --config, -c PATH" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--config']:-} ]] || args['--config']="salmo.config.yml"

}

# :command.parse_requirements
salmo_install_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        salmo_install_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="install"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --dry-run | -n)

        # :flag.case_no_arg
        args['--dry-run']=1
        shift
        ;;

      # :flag.case
      --file | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--file']="$2"
          shift
          shift
        else
          printf "%s\n" "--file requires an argument: --file, -f FILEPATH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --config | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--config']="$2"
          shift
          shift
        else
          printf "%s\n" "--config requires an argument: --config, -c CONFIGPATH" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--file']:-} ]] || args['--file']="pkglist.txt"
  [[ -n ${args['--config']:-} ]] || args['--config']="salmo.config.yml"

}

# :command.parse_requirements
salmo_pull_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        salmo_pull_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="pull"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.user_hooks
before_hook() {
  # src/before.sh

  # Define default values
  SALMO_FILES_DIR="./src/files"
  SALMO_PACKAGES_FILE="./src/packages.yml"
  SALMO_DEFAULT_PACKAGE_MANAGER="pacman"
  SALMO_BUILD_OUT_DIR="./dist"
  SALMO_BUILD_FILENAME="luis-de"

  # Load configuration
  CONFIG_PATH="${args[--config]}"

  if [[ -f "$CONFIG_PATH" ]]; then
      log_info "Loading configuration from $CONFIG_PATH"
      eval "$(yaml_load "$CONFIG_PATH" SALMO_)"
  fi

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"
  before_hook

  case "$action" in
    "prepare") salmo_prepare_command ;;
    "dev") salmo_dev_command ;;
    "build") salmo_build_command ;;
    "install") salmo_install_command ;;
    "pull") salmo_pull_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
